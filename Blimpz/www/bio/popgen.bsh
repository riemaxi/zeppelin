/*style_main
#frame{
    -fx-font-size: 11pt;
    -fx-font-family: "Verdana";
    -fx-background: white;
    -fx-text-fill: white;
}
style_main*/

/*uix_main
<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.scene.canvas.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<AnchorPane fx:id="frame" prefHeight="426.0" prefWidth="657.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <SplitPane fx:id="mainsplitter" dividerPositions="0.7525252525252525" focusTraversable="true" orientation="VERTICAL" prefHeight="200.0" prefWidth="320.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
        <items>
          <AnchorPane fx:id="viewHost" minHeight="0.0" minWidth="0.0" prefHeight="100.0" prefWidth="160.0">
               <children>
                  <Canvas fx:id="view" height="200.0" width="200.0" AnchorPane.bottomAnchor="30.0" AnchorPane.leftAnchor="30.0" AnchorPane.rightAnchor="14.0" AnchorPane.topAnchor="14.0" />
               </children>
            </AnchorPane>
          <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="100.0" prefWidth="160.0">
               <children>
                  <SplitPane fx:id="commandsplitter" dividerPositions="0.6110260336906586" focusTraversable="true" prefHeight="102.0" prefWidth="655.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                    <items>
                      <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                           <children>
                              <TextArea fx:id="command" prefHeight="100.0" prefWidth="396.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
                           </children>
                        </AnchorPane>
                      <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="160.0" prefWidth="100.0">
                           <children>
                              <TextArea fx:id="stats" prefHeight="100.0" prefWidth="251.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
                           </children>
                        </AnchorPane>
                    </items>
                  </SplitPane>
               </children>
            </AnchorPane>
        </items>
      </SplitPane>
   </children>
</AnchorPane>
uix_main*/

//Begin controller
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.event.EventHandler;
import javafx.scene.paint.Color;
import java.lang.String;
import java.util.function.Consumer;
import javafx.beans.value.ChangeListener;
import javafx.scene.layout.AnchorPane;
import java.util.concurrent.SynchronousQueue;

//Begin model
generation(n, freq){
    int nr = n;
    double[] frequency = new double[freq.length];
    for(i=0; i<freq.length; i++)
        frequency[i] = freq[i];

    return this;
};

popstate(c,w){
    Color color = c;
    int width = w;
    return this;
};

generations = 100;
arrivals = new SynchronousQueue();
genlist = new ArrayList();
state = null;

stats = null;
command = null;
view = null;
vframe = null;

tmargin = 0.0;
bmargin = 0.0;
lmargin = 0.0;
rmargin = 0.0;
xscale = 1;
yscale = 1;
bgColor = "#DDDDDD";
playSpeed = 5;
//End model

execute(c){
    this.args = c.split(" ");
    switch(args[0].trim()){
        case "sim" : simulate(this.args[1].trim()); break;
        default: command.setText(command.getText() + "no command");
    }
}

//Handlers
streamHandler(){
    return new Consumer(){
        accept(gen){
            arrivals.put( generation(gen.genr, gen.frequency) );
        }
    };
}

commandHandler(){
    return new EventHandler(){
        handle(ev){
            if (ev.getCode() == KeyCode.ENTER){
                String[] params = command.getText().split("\n");
                execute(params[params.length-1].trim());
            }
        }
    };
}

playerHandler(){
    return new Consumer(){
        accept(data){
            arrivals.drainTo(genlist);
            paint();
            summary(genlist.size()-1);

            if (genlist.size()>=generations){
                context.player.stop();
                summary(0);
             }
        }
    };
}

frameHhandler(){
    return new ChangeListener(){    
        changed(ob, ov, nv){
            adjust(ov, nv, false);
        }
    };
}

frameWhandler(){
    return new ChangeListener(){    
        changed(ob, ov, nv){
            adjust(ov, nv, true );
        }
    };
}


//Utils
reportheader = "generation\t\tfixed\t\tlost\n";
report = new StringBuffer(reportheader);

summary(from){
    if (genlist.size()==0)
        return;

    report.setLength(reportheader.length());
    for(k=from; k<genlist.size(); k++){
        g = genlist.get(k);
        fixed = 0;
        lost = 0;
        for(i=0; i<g.frequency.length; i++){
            f = g.frequency[i];
            fixed = fixed + (f==1?1:0);
            lost = lost + (f==0?1:0);
        }
        report.append(g.nr).append("\t\t\t").append(fixed).append("\t\t").append(lost).append("\n");
    }

    stats.setText(report.toString());
}

adjust(){
   view.setWidth(vframe.getWidth() - (lmargin + rmargin));
   view.setHeight(vframe.getHeight() - (tmargin + bmargin));

   paint();        
}

adjust(ov,nv,w){
    if (w)
      view.setWidth(nv.doubleValue() - (lmargin + rmargin));
    else
      view.setHeight(nv.doubleValue() - (tmargin + bmargin));

    paint();        
}

clearBackground(){
    gc = view.getGraphicsContext2D();
    gc.setFill(Color.valueOf(bgColor));
    gc.fillRect(0, 0, view.getWidth(), view.getHeight());
}

setScale(){
    xscale = view.getWidth()/(generations-1);
    yscale = view.getHeight();
}

updateStateColor(){
    if (genlist.size()>0){
        gen = genlist.get(genlist.size()-1);
        for(i=0; i<gen.frequency.length; i++){
            f = gen.frequency[i];
            state[i].color = (f==1?Color.GREEN:(f==0?Color.RED:Color.BLACK));
        }
     }
}


paintTracks(){
    updateStateColor();
    gc = view.getGraphicsContext2D();
    gc.setFill(Color.BLACK);
    for(i=1; i<genlist.size(); i++){
        prevg = genlist.get(i-1);
        g = genlist.get(i);
        for(k=0; k< g.frequency.length; k++){
            gc.setStroke(state[k].color);
            gc.setLineWidth(state[k].width);

            ax = (i-1) * xscale;
            ay = (1-prevg.frequency[k]) *yscale;
            bx = i * xscale;
            by = (1-g.frequency[k]) *yscale;

            gc.strokeLine(ax,ay, bx, by);
        }
    }
}

paint(){
    setScale();
    clearBackground();
    paintTracks();
}

simulate(source){
    state = new Object[10];
    for(i=0; i<state.length; i++)
        state[i] = popstate(Color.BLACK, 2);

    genlist.clear();
    arrivals.clear();
    context.player.play(playSpeed, playerHandler());
    context.stream(source, streamHandler() );
}

//End controller


//Begin interface
init(){
    vframe = context.get("viewHost");
    vframe.heightProperty().addListener(frameHhandler());
    vframe.widthProperty().addListener(frameWhandler());

    view = context.get("view");
    stats = context.get("stats");

    command = context.get("command");
    command.addEventHandler(KeyEvent.KEY_RELEASED, commandHandler());

    tmargin = AnchorPane.getTopAnchor(view).doubleValue();
    bmargin = AnchorPane.getBottomAnchor(view).doubleValue();
    lmargin = AnchorPane.getLeftAnchor(view).doubleValue();
    rmargin = AnchorPane.getRightAnchor(view).doubleValue();

    context.stage.setTitle("Advanced Population Genetics");

    adjust();
}

uiaddress(){
    return null;
}

ui(id){
 return "uix_" + id;
}

ui(){
 return ui("main");
}

style(){
    return style("main");
}

style(id){
    return "style_" + id;
}

stylePath(){
    return "style.css";
}

loaded(){
};
//End interface